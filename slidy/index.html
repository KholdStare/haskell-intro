<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Alexander Kondratskiy" />
  <meta name="date" content="2013-05-15" />
  <title>Haskell Intro</title>
  <link rel="stylesheet" type="text/css" media="screen, projection, print" href="slidy.css" />
  <link rel="stylesheet" type="text/css" href="style.css" />
  <script src="slidy.js" charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Haskell Intro</h1>
  <p class="author">Alexander Kondratskiy<br/><code>kholdstare0.0﹫gmail·com</code><br/>
  </p>
  <p class="date">2013-05-15</p>
</div>
<div id="haskell" class="titleslide slide section level1"><h1>HASKELL</h1></div><div id="first-language" class="slide section level2">
<h1>First Language</h1>
<blockquote>
“The most disastrous thing that you can ever learn is your first programming language.” ― Alan Kay (pioneer in OOP)
</blockquote>

<ul>
<li>First programming language shapes habits, limits thinking
<ul>
<li>Overuse of <code>new</code> in C++ coming from Java</li>
<li>Indexed <code>for</code> loops in Python coming from C</li>
</ul></li>
<li>Good to &quot;grok&quot; others to gain perspective</li>
</ul>
</div><div id="haskell-1" class="slide section level2">
<h1>Haskell</h1>
<ul>
<li>Haskell is unlike any other language</li>
<li>Language Design decisions opose the status quo
<ul>
<li>But brilliantly so</li>
</ul></li>
<li>Many advantages gained as a result
<ul>
<li>It's fun to program again!</li>
</ul></li>
</ul>
<div class="figure">
<img src="images/HaskellLogo.jpg" />
</div>
</div><div id="quicksort" class="slide section level2">
<h1>QuickSort</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">quicksort ::</span> <span class="kw">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
quicksort []     <span class="fu">=</span> []
quicksort (p<span class="fu">:</span>xs) <span class="fu">=</span>
    (quicksort lesser) <span class="fu">++</span> [p] <span class="fu">++</span> (quicksort greater)
    <span class="kw">where</span>
        lesser  <span class="fu">=</span> <span class="fu">filter</span> (<span class="fu">&lt;</span> p) xs
        greater <span class="fu">=</span> <span class="fu">filter</span> (<span class="fu">&gt;=</span> p) xs</code></pre>
<aside class="notes">

<ul>
<li>High level</li>
<li>Declarative</li>
<li><p>Elegant</p></li>
<li>No variable assignments</li>
<li>Breaks into cases
</aside>
</li>
</ul>
</div><div id="haskell-platform" class="slide section level2">
<h1>Haskell Platform</h1>
<p>Cross-platform distribution with trusted libraries TODO: image</p>
</div><div id="hackage" class="slide section level2">
<h1>Hackage</h1>
<p>Rich open source library repository</p>
<p>TODO: images</p>
</div><div id="cabal" class="slide section level2">
<h1>Cabal</h1>
<p>Package management</p>
<p>TODO: images</p>
</div><div id="ghc" class="slide section level2">
<h1>GHC</h1>
<p>Glasgow Haskell compiler * compiles to native code</p>
</div><div id="ghci" class="slide section level2">
<h1>GHCi</h1>
<p>Interpreter TODO: image</p>
</div><div id="hoogle" class="slide section level2">
<h1>Hoogle</h1>
<p>Search yours and other's libraries by type signatures (!!!)</p>
<p>TODO: image TODO: sort example?</p>
</div><div id="haskell-2" class="slide section level2">
<h1>Haskell</h1>
<p>More formally...</p>
<blockquote>
Haskell is a purely functional, statically typed programming language, with non-strict evaluation.
</blockquote>

</div><div id="wat" class="slide section level2">
<h1><strong>WAT</strong></h1>
</div>
<div id="the-language" class="titleslide slide section level1"><h1>The Language</h1></div><div id="the-language-1" class="slide section level2">
<h1>The Language</h1>
<ul>
<li>Purely functional
<ul>
<li>Pure - no side effects!</li>
<li>Functional - functions are first-class values!</li>
</ul></li>
<li>Statically typed
<ul>
<li>Rich type system</li>
<li>Inference engine</li>
<li>Type polymorphism, Kinds, Kind Polymorphism</li>
</ul></li>
<li>Non-strict evaluation
<ul>
<li>A.k.a. lazy evaluation</li>
</ul></li>
</ul>
</div><div id="quicksort-1" class="slide section level2">
<h1>QuickSort</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">quicksort ::</span> <span class="kw">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
quicksort []     <span class="fu">=</span> []
quicksort (p<span class="fu">:</span>xs) <span class="fu">=</span>
    (quicksort lesser) <span class="fu">++</span> [p] <span class="fu">++</span> (quicksort greater)
    <span class="kw">where</span>
        lesser  <span class="fu">=</span> <span class="fu">filter</span> (<span class="fu">&lt;</span> p) xs
        greater <span class="fu">=</span> <span class="fu">filter</span> (<span class="fu">&gt;=</span> p) xs</code></pre>
<aside class="notes">
    
<ul>
<li>No variable assignments
<ul>
<li>Breaks into cases
</aside>
</li>
</ul></li>
</ul>
</div><div id="pure" class="slide section level2">
<h1>Pure</h1>
<ul>
<li>Functions are functions in the <em>mathematical</em> sense</li>
<li>No side effects within functions
<ul>
<li>No mutation, assignment or implicit state</li>
<li>Everything is immutable</li>
<li>No IO</li>
<li>No global state</li>
</ul></li>
</ul>
</div><div id="pure-1" class="slide section level2">
<h1>Pure</h1>
<ul>
<li>Functions are referentially transparent
<ul>
<li>Repeatable results</li>
<li>Great for testing</li>
</ul></li>
<li>Allows for pervasive sharing
<ul>
<li>If everything immutable, no worry about mutation</li>
<li>Concurrency/Parallelism is trivial</li>
</ul></li>
</ul>
</div><div id="pure-2" class="slide section level2">
<h1>Pure</h1>
<ul>
<li>Some intuition: Excel Spreadsheet
<ul>
<li>User-specified cells are inputs</li>
<li>Formula cells are outputs</li>
<li>Cells are not updated as state by Excel</li>
<li>Can be easily parallelized</li>
</ul></li>
</ul>
<p>TODO: Excel picture</p>
</div><div id="functional" class="slide section level2">
<h1>Functional</h1>
<ul>
<li>Functions are first-class values
<ul>
<li>Can be passed around</li>
<li>Can be defined inline (lambda functions)</li>
</ul></li>
<li>Higher-order functions
<ul>
<li>Functions that return new functions</li>
</ul></li>
</ul>
</div><div id="functional-1" class="slide section level2">
<h1>Functional</h1>
<ul>
<li>Limited intuition in imperative languages:
<ul>
<li><code>qsort</code> from C</li>
</ul></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> qsort(
    <span class="dt">void</span> *ptr,
    size_t count,
    size_t size,
    <span class="co">// function as a parameter</span>
    <span class="dt">int</span> (*comp)(<span class="dt">const</span> <span class="dt">void</span> *, <span class="dt">const</span> <span class="dt">void</span> *)
);</code></pre>
<aside class="notes">
    
<ul>
<li>Function pointers not a closure
<ul>
<li>Can't return a new function
</aside>
</li>
</ul></li>
</ul>
</div><div id="lazy" class="slide section level2">
<h1>Lazy</h1>
<ul>
<li>Lazy by default</li>
<li>Evaluates values when they are needed</li>
</ul>
</div><div id="lazy-1" class="slide section level2">
<h1>Lazy</h1>
<ul>
<li>Some intuition:
<ul>
<li>Short circuiting of boolean expressions</li>
</ul></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (pointer != NULL &amp;&amp; pointer-&gt;doesSomething())
{
    <span class="co">// ...</span>
}
<span class="kw">else</span> <span class="kw">if</span> (number &lt; <span class="dv">0</span> || number &gt; <span class="dv">100</span>)
{
    <span class="co">// ...</span>
}</code></pre>
</div><div id="haskell-philosophy" class="slide section level2">
<h1>Haskell Philosophy</h1>
<ul>
<li>&quot;What&quot; rather than &quot;How&quot;</li>
<li>Data flow</li>
<li>Purity</li>
<li>Composition</li>
</ul>
</div>
<div id="syntax-intro" class="titleslide slide section level1"><h1>Syntax Intro</h1></div><div id="defining-values" class="slide section level2">
<h1>Defining Values</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- define a value</span>
x <span class="fu">=</span> <span class="dv">42</span>
<span class="co">-- cannot reassign x = 7</span>

<span class="co">-- functions are also values</span>
addOneTo v <span class="fu">=</span> v <span class="fu">+</span> <span class="dv">1</span></code></pre>
<ul>
<li><code>=</code> is Mathematical Equality</li>
<li><em>Not</em> assignment</li>
<li>Both sides are <em>equivalent</em>
<ul>
<li>Left can be substituted by right</li>
<li>And vice versa</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Mention cannot reassign - not a VARiable</li>
<li>Functions are values just like integers
</aside>
</li>
</ul>
</div><div id="type-annotations" class="slide section level2">
<h1>Type annotations</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">x ::</span> <span class="dt">Int</span>
x <span class="fu">=</span> <span class="dv">5</span>

<span class="ot">y ::</span> <span class="dt">Double</span>
y <span class="fu">=</span> <span class="dv">4</span><span class="fu">.</span><span class="dv">2</span>

<span class="ot">addOneTo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
addOneTo v <span class="fu">=</span> v <span class="fu">+</span> <span class="dv">1</span></code></pre>
<ul>
<li>Everything has a type</li>
<li><code>::</code> allows us to annotate values with types</li>
<li>Concrete types always <em>Capitalized</em></li>
<li><code>a -&gt; b</code> denotes a function from <code>a</code> to <code>b</code></li>
</ul>
</div><div id="function-application" class="slide section level2">
<h1>Function application</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">six ::</span> <span class="dt">Int</span>
six <span class="fu">=</span> addOneTo <span class="dv">5</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="fu">print</span> six</code></pre>
</div><div id="new-data-types" class="slide section level2">
<h1>New Data types</h1>
<ul>
<li>We have seen some types</li>
<li>Let's see the <code>Bool</code> definition</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--   \/~~ new type name</span>
<span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="kw">True</span> <span class="fu">|</span> <span class="kw">False</span>
<span class="co">--           /\     /\</span>
<span class="co">--   Possible values in type</span></code></pre>
</div><div id="pattern-matching" class="slide section level2">
<h1>Pattern Matching</h1>
<ul>
<li>We can inspect structure of arguments in function definitions
<ul>
<li>Called Pattern Matching</li>
</ul></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Using built-in if</span>
<span class="ot">boolToString ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
boolToString b <span class="fu">=</span> <span class="kw">if</span> b <span class="kw">then</span> <span class="st">&quot;Yes!&quot;</span> <span class="kw">else</span> <span class="st">&quot;No!&quot;</span>

<span class="co">-- Using Pattern Matching</span>
<span class="ot">boolToString&#39; ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
boolToString&#39; <span class="kw">True</span>  <span class="fu">=</span> <span class="st">&quot;Yes!&quot;</span>
boolToString&#39; <span class="kw">False</span> <span class="fu">=</span> <span class="st">&quot;No!&quot;</span></code></pre>
<aside class="notes">
<ul>
<li>&quot;Unpacking&quot; the argument
</aside>
</li>
</ul>
</div><div id="factorial-example" class="slide section level2">
<h1>Factorial Example</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Pattern matching and recursion</span>
<span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
factorial <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
factorial n <span class="fu">=</span> n <span class="fu">*</span> factorial (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre>
<aside class="notes">
<ul>
<li>Mention <code>data Int =</code>1 | 2 | 3 | 4 ...`
</aside>
</li>
</ul>
</div><div id="lists" class="slide section level2">
<h1>Lists</h1>
<table>
<thead>
<tr class="header">
<th align="left">Syntax</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>[]</code></td>
<td align="left">Empty List</td>
</tr>
<tr class="even">
<td align="left"><code>[1, 2, 3]</code></td>
<td align="left">List</td>
</tr>
<tr class="odd">
<td align="left"><code>1 : [2, 3]</code></td>
<td align="left">Prepend to a list</td>
</tr>
<tr class="even">
<td align="left"><code>[1, 2] ++ [3, 4]</code></td>
<td align="left">Concatenate two lists</td>
</tr>
<tr class="odd">
<td align="left"><code>&quot;Hello&quot; :: [Char]</code></td>
<td align="left">Strings are lists of <code>Char</code></td>
</tr>
<tr class="even">
<td align="left"><code>&quot;He&quot; ++ &quot;llo&quot;</code></td>
<td align="left">Concatenate two strings</td>
</tr>
</tbody>
</table>
</div><div id="list-operations" class="slide section level2">
<h1>List operations</h1>
<p>Pattern match on <code>:</code> construction.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Get first element</span>
<span class="fu">head</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a
<span class="fu">head</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> x</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Get list after first element</span>
<span class="fu">tail</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]
<span class="fu">tail</span> []     <span class="fu">=</span> []
<span class="fu">tail</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> xs</code></pre>
<aside class="notes">
<ul>
<li>Pattern match against list construction <code>:</code></li>
<li>Parametric polymorphism</li>
<li>We don't assume anything about list elements themselves</li>
<li>Cover empty case</li>
<li>mention <code>error &quot;empty list&quot;</code> only if asked
</aside>
</li>
</ul>
</div><div id="reverse-a-list" class="slide section level2">
<h1>Reverse a List</h1>
<p>Pattern matching is your friend</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myReverse ::</span> [a] <span class="ot">-&gt;</span> [a]
myReverse [] <span class="fu">=</span> []
myReverse (x<span class="fu">:</span>xs) <span class="fu">=</span> myReverse xs <span class="fu">++</span> [x]</code></pre>
<p>Reuse <code>head</code> and <code>tail</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myReverse ::</span> [a] <span class="ot">-&gt;</span> [a]
myReverse [] <span class="fu">=</span> []
myReverse list <span class="fu">=</span> myReverse (<span class="fu">tail</span> list) <span class="fu">++</span> [<span class="fu">head</span> list]</code></pre>
<aside class="notes">
<ul>
<li>Can make it more generic
</aside>
</li>
</ul>
</div>
<div id="function-example" class="titleslide slide section level1"><h1>Function Example</h1></div><div id="summing-a-list" class="slide section level2">
<h1>Summing a list</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mySum ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
mySum []     <span class="fu">=</span> <span class="dv">0</span>
mySum (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> (mySum xs)</code></pre>
</div><div id="substitution" class="slide section level2">
<h1>Substitution</h1>
<p>Let's evaluate <code>mySum</code> on a small list, by following substitution rules</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- mySum []     = 0</span>
<span class="co">-- mySum (x:xs) = x + (mySum xs)</span>
  mySum [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
<span class="fu">=</span> mySum <span class="dv">1</span><span class="fu">:</span>[<span class="dv">2</span>,<span class="dv">3</span>]
<span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (mySum [<span class="dv">2</span>,<span class="dv">3</span>])
<span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (mySum <span class="dv">2</span><span class="fu">:</span>[<span class="dv">3</span>])
<span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> ( <span class="dv">2</span> <span class="fu">+</span> (mySum [<span class="dv">3</span>]))
<span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> ( <span class="dv">2</span> <span class="fu">+</span> (mySum <span class="dv">3</span><span class="fu">:</span>[]))
<span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> ( <span class="dv">2</span> <span class="fu">+</span> ( <span class="dv">3</span> <span class="fu">+</span> (mySum [])))
<span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> ( <span class="dv">2</span> <span class="fu">+</span> ( <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">0</span>)))
<span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> ( <span class="dv">2</span> <span class="fu">+</span> ( <span class="dv">3</span> ))
<span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> ( <span class="dv">5</span> )
<span class="fu">=</span> <span class="dv">6</span></code></pre>
<p>Inefficient: requires O(n) space!</p>
</div><div id="tail-recursion" class="slide section level2">
<h1>Tail Recursion</h1>
<ul>
<li>Can we use O(1) space?</li>
<li>Use tail recursion to implement a new sum function:</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Takes an accumulator as first argument</span>
<span class="ot">mySum&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
mySum&#39; acc []     <span class="fu">=</span> acc
mySum&#39; acc (x<span class="fu">:</span>xs) <span class="fu">=</span> mySum&#39; (acc <span class="fu">+</span> x) xs
<span class="co">-- ^ add the head of the list to the accumulator</span></code></pre>
<ul>
<li>No computation to be done after recursive call</li>
<li>Essentially replace the current context with recursive call</li>
</ul>
</div><div id="tail-recursion-1" class="slide section level2">
<h1>Tail Recursion</h1>
<p>To see why this takes constant space, let's use substitution rules:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- mySum&#39; acc []     = acc</span>
<span class="co">-- mySum&#39; acc (x:xs) = mySum&#39; (acc + x) xs</span>
  mySum&#39; <span class="dv">0</span>     [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
<span class="fu">=</span> mySum&#39; <span class="dv">0</span>     <span class="dv">1</span><span class="fu">:</span>[<span class="dv">2</span>,<span class="dv">3</span>]
<span class="fu">=</span> mySum&#39; (<span class="dv">0</span><span class="fu">+</span><span class="dv">1</span>) [<span class="dv">2</span>,<span class="dv">3</span>]
<span class="fu">=</span> mySum&#39; <span class="dv">1</span>     <span class="dv">2</span><span class="fu">:</span>[<span class="dv">3</span>]
<span class="fu">=</span> mySum&#39; (<span class="dv">1</span><span class="fu">+</span><span class="dv">2</span>) [<span class="dv">3</span>]
<span class="fu">=</span> mySum&#39; <span class="dv">3</span>     <span class="dv">3</span><span class="fu">:</span>[]
<span class="fu">=</span> mySum&#39; (<span class="dv">3</span><span class="fu">+</span><span class="dv">3</span>) []
<span class="fu">=</span> mySum&#39; <span class="dv">6</span>     []
<span class="fu">=</span> <span class="dv">6</span></code></pre>
<p>This is equivalent to a flat loop in an imperative language.</p>
</div><div id="tail-recursion-2" class="slide section level2">
<h1>Tail Recursion</h1>
<ul>
<li>Let's encapsulate this accumulator implementation</li>
<li>Use <code>where</code> for scoped definitions</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mySum ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="co">-- call implementation with 0 accumulator</span>
mySum xs <span class="fu">=</span> mySum&#39; <span class="dv">0</span>   xs
     <span class="kw">where</span> mySum&#39; acc []     <span class="fu">=</span> acc
           mySum&#39; acc (x<span class="fu">:</span>xs) <span class="fu">=</span> mySum&#39; (acc <span class="fu">+</span> x) xs</code></pre>
</div><div id="towards-reusability" class="slide section level2">
<h1>Towards Reusability</h1>
<ul>
<li>The type signature of <code>mySum</code> is quite restrictive</li>
<li>We may want to sum
<ul>
<li><code>Float</code>s</li>
<li><code>Double</code>s</li>
<li><code>Complex</code> numbers</li>
</ul></li>
<li>Can we make it generic?</li>
</ul>
</div>
<div id="type-inference" class="titleslide slide section level1"><h1>Type Inference</h1></div><div id="type-inference-1" class="slide section level2">
<h1>Type Inference</h1>
<ul>
<li>The compiler can infer types</li>
<li>We can neglect type signatures</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Compiles without type signature!</span>
mySum xs <span class="fu">=</span> mySum&#39; <span class="dv">0</span>   xs
     <span class="kw">where</span> mySum&#39; acc []     <span class="fu">=</span> acc
           mySum&#39; acc (x<span class="fu">:</span>xs) <span class="fu">=</span> mySum&#39; (acc <span class="fu">+</span> x) xs</code></pre>
<ul>
<li>And ask the compiler what it thinks:</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Query the type in interpreter</span>
<span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> mySum
<span class="ot">mySum ::</span> <span class="kw">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</code></pre>
</div><div id="type-inference---how" class="slide section level2">
<h1>Type Inference - How?</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--  Says &quot;Type parameter a has to be a Number&quot;</span>
<span class="ot">mySum ::</span> <span class="kw">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
mySum xs <span class="fu">=</span> mySum&#39; <span class="dv">0</span>   xs
     <span class="kw">where</span> mySum&#39; acc []     <span class="fu">=</span> acc
           mySum&#39; acc (x<span class="fu">:</span>xs) <span class="fu">=</span> mySum&#39; (acc <span class="fu">+</span> x) xs
<span class="co">--                the clue to the compiler ^</span></code></pre>
<ul>
<li>The compiler looks at what we have used:
<ul>
<li>Elements combined with operator <code>+</code></li>
</ul></li>
<li>The &quot;interface&quot; that exposes <code>+</code> is <code>Num</code></li>
<li>Therefore <code>mySum</code> can only be used on lists of <code>Num</code>s</li>
</ul>
</div><div id="type-inference-2" class="slide section level2">
<h1>Type Inference</h1>
<ul>
<li>Let's try on different types:</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> mySum [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>]
<span class="dv">28</span><span class="ot"> ::</span> <span class="dt">Int</span>

<span class="fu">&gt;</span> mySum [<span class="dv">2</span><span class="fu">.</span><span class="dv">5</span>, <span class="dv">3</span><span class="fu">.</span><span class="dv">5</span>, <span class="dv">4</span><span class="fu">.</span><span class="dv">5</span>, <span class="dv">5</span><span class="fu">.</span><span class="dv">5</span>, <span class="dv">6</span><span class="fu">.</span><span class="dv">5</span>, <span class="dv">7</span><span class="fu">.</span><span class="dv">5</span>]
<span class="dv">30</span><span class="fu">.</span><span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Double</span></code></pre>
</div><div id="type-inference---benefits" class="slide section level2">
<h1>Type Inference - Benefits</h1>
<ul>
<li>Compiler infers most generic type</li>
<li>Genericity for free</li>
<li>Type annotations more useful to programmers than compiler</li>
</ul>
<aside class="notes">
<ul>
<li>Mention UML
</aside>
</li>
</ul>
</div>
<div id="control-structures" class="titleslide slide section level1"><h1>Control Structures</h1></div><div id="control-structures-1" class="slide section level2">
<h1>Control Structures</h1>
<ul>
<li>Are there really no control structures?
<ul>
<li><code>if</code> ?</li>
<li><code>while</code> ?</li>
<li><code>for</code> ?</li>
</ul></li>
<li>We can construct our own!
<ul>
<li>Due to Haskell's laziness</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Imperative control structures awkward in functional setting</li>
<li>Better alternatives exist
</aside>
</li>
</ul>
</div>
<div id="abstracting-loops" class="titleslide slide section level1"><h1>Abstracting loops</h1></div><div id="abstracting-loops-1" class="slide section level2">
<h1>Abstracting loops</h1>
<ul>
<li>For loops are very low level
<ul>
<li>No inherent semantics</li>
</ul></li>
<li>Transforming a list - <code>map</code></li>
<li>Accumulating over a list - <code>fold</code></li>
</ul>
</div><div id="map" class="slide section level2">
<h1>Map</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</code></pre>
<p><code>map f xs</code> is the list obtained by applying f to each element of xs, i.e.,</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">map</span> f [x1, x2, <span class="fu">...</span>, xn] <span class="fu">==</span> [f x1, f x2, <span class="fu">...</span>, f xn]
<span class="fu">&gt;</span> <span class="fu">map</span> f [x1, x2, <span class="fu">...</span>] <span class="fu">==</span> [f x1, f x2, <span class="fu">...</span>] </code></pre>
</div><div id="map-1" class="slide section level2">
<h1>Map</h1>
<ul>
<li>Map works by applying another function over a list</li>
<li>We have to pass a function to map
<ul>
<li>Similar to C's <code>qsort</code></li>
</ul></li>
</ul>
</div><div id="map-2" class="slide section level2">
<h1>Map</h1>
<figure>
<object width="100%" data="diagrams/MapFunction.svg" type="image/svg+xml">
    
<img src="diagrams/MapFunction.png" />
</object>
</figure>

</div><div id="map-3" class="slide section level2">
<h1>Map</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">map</span> (<span class="fu">*</span><span class="dv">2</span>) [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]
[<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">10</span>]</code></pre>
<figure>
<object width="100%" data="diagrams/MapTimesTwo.svg" type="image/svg+xml">
    
<img src="diagrams/MapTimesTwo.png" />
</object>
</figure>

<aside class="notes">
<ul>
<li>Mention <code>std::transform</code> equivalent in stl
</aside>

</li>
</ul>
</div><div id="functions" class="slide section level2">
<h1>Functions</h1>
<p>TODO: functions</p>
<ul>
<li>Functions are first class values!
<ul>
<li>Can be passed around</li>
<li>Can be equaded</li>
<li>Can be created</li>
</ul></li>
</ul>
</div><div id="functions---passed-around" class="slide section level2">
<h1>Functions - Passed Around</h1>
<ul>
<li>Accumulating over a list is abstracted as a &quot;fold&quot;</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">foldl</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a
<span class="co">--       ~~~~~~~~~~~~~    ^- starting value (accumulator)</span>
<span class="co">--      binary operator</span></code></pre>
<blockquote>
<p>foldl, applied to a <strong>binary operator</strong>, a <strong>starting value</strong> (typically the left-identity of the operator), and <strong>a list</strong>, reduces the list using the binary operator, from left to right.</p>
</blockquote>
<p>TODO: diagram of foldl?</p>
</div><div id="functions---passed-around-1" class="slide section level2">
<h1>Functions - Passed Around</h1>
<ul>
<li>Accumulating over a list is abstracted as a &quot;fold&quot;</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">foldl</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a
<span class="ot">(+)   ::</span> <span class="kw">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a

mySum xs <span class="fu">=</span> <span class="fu">foldl</span> (<span class="fu">+</span>) <span class="dv">0</span> xs</code></pre>
</div><div id="functions---created" class="slide section level2">
<h1>Functions - Created</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]

doubleValues xs <span class="fu">=</span> <span class="fu">map</span> (\x <span class="ot">-&gt;</span> x <span class="fu">*</span> <span class="dv">2</span>) xs
<span class="co">--                    ~^~~~~~~~~~~~</span>
<span class="co">--                   lambda function</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> doubleValues [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]
[<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">10</span>]</code></pre>
</div><div id="functions---equaded" class="slide section level2">
<h1>Functions - Equaded</h1>
<ul>
<li>Functions are values</li>
<li>Values can be defined in terms of other values</li>
<li>Define one function by equading to another
<ul>
<li>This is called <em>pointfree</em> notation</li>
</ul></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">toUpper</span><span class="ot"> ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
<span class="fu">map</span><span class="ot">     ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]

<span class="ot">stringToUpper ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
stringToUpper s <span class="fu">=</span> <span class="fu">map</span> (<span class="fu">toUpper</span>) s

<span class="co">-- factor out s</span>
<span class="ot">stringToUpper&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
stringToUpper&#39; <span class="fu">=</span> <span class="fu">map</span> (<span class="fu">toUpper</span>)</code></pre>
</div><div id="functions---equaded-1" class="slide section level2">
<h1>Functions - Equaded</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stringToUpper ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
stringToUpper <span class="fu">=</span> <span class="fu">map</span> (<span class="fu">toUpper</span>) </code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> stringToUpper <span class="st">&quot;Hello World&quot;</span>
<span class="st">&quot;HELLO WORLD&quot;</span></code></pre>
</div><div id="more-reusability" class="slide section level2">
<h1>More Reusability?</h1>
<ul>
<li>Our <code>mySum</code> function works great for adding a list of numbers</li>
<li>But more types can be aggregated:
<ul>
<li>e.g. <code>String</code>s</li>
</ul></li>
<li>Can we capture this behaviour in an &quot;interface&quot;?</li>
</ul>
</div>
<div id="typeclasses" class="titleslide slide section level1"><h1>Typeclasses</h1></div><div id="typeclasses-1" class="slide section level2">
<h1>Typeclasses</h1>
<ul>
<li>Typeclasses are the &quot;interfaces&quot; of Haskell</li>
<li>Much more flexible and general</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- The Num typeclass we saw before</span>
<span class="kw">class</span> <span class="kw">Num</span> a <span class="kw">where</span>
<span class="ot">    (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">    (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">    (-) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">    negate ::</span> a <span class="ot">-&gt;</span> a
<span class="ot">    abs ::</span> a <span class="ot">-&gt;</span> a</code></pre>
<ul>
<li>Anything can be treated as a number as long as it defines the above functions</li>
</ul>
</div><div id="typeclasses---instances" class="slide section level2">
<h1>Typeclasses - Instances</h1>
<ul>
<li>A Data Type can adhere to a typeclass by specifying an <code>instance</code></li>
<li>Attach behaviour after the fact onto existing Data Type</li>
</ul>
<p>TODO: &quot;filling in the 'a' &quot;</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Num</span> <span class="dt">Int</span> <span class="kw">where</span>
    (<span class="fu">+</span>) <span class="fu">=</span> intSum  <span class="co">-- assuming intSum</span>
    (<span class="fu">*</span>) <span class="fu">=</span> intMult <span class="co">--          intMult</span>
    (<span class="fu">-</span>) <span class="fu">=</span> intSub  <span class="co">--          intSub are provided elsewhere</span>
    <span class="fu">negate</span> x <span class="fu">=</span>  <span class="dv">0</span> <span class="fu">-</span> x
    <span class="fu">abs</span> x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&lt;</span> <span class="dv">0</span>
            <span class="kw">then</span> <span class="fu">negate</span> x
            <span class="kw">else</span> x</code></pre>
</div><div id="more-typeclasses" class="slide section level2">
<h1>More Typeclasses</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Eq</span> a <span class="kw">where</span>
<span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">    (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">class</span> <span class="kw">Eq</span> a <span class="ot">=&gt;</span> <span class="kw">Ord</span> a <span class="kw">where</span>
    <span class="co">-- minimal definition requires compare</span>
    <span class="co">-- the rest are automatically defined in terms of it</span>
<span class="ot">    compare ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>
<span class="ot">    (&lt;)  ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">    (&gt;=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">    (&gt;)  ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">    (&lt;=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">    max  ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">    min  ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre>
</div><div id="generic-functions" class="slide section level2">
<h1>Generic functions</h1>
<ul>
<li>Typeclasses decouple behaviour and polymorphism from data.</li>
<li>Wealth of reusable functions to be used</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">sort</span><span class="ot"> ::</span> <span class="kw">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="co">-- example:</span>
<span class="fu">sort</span> <span class="st">&quot;Missisauga&quot;</span> <span class="fu">=</span> <span class="st">&quot;Maagiissssu&quot;</span>

<span class="fu">group</span><span class="ot"> ::</span> <span class="kw">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]
<span class="co">-- example:</span>
<span class="fu">group</span> <span class="st">&quot;Missisauga&quot;</span> <span class="fu">=</span> [<span class="st">&quot;M&quot;</span>,<span class="st">&quot;i&quot;</span>,<span class="st">&quot;ss&quot;</span>,<span class="st">&quot;i&quot;</span>,<span class="st">&quot;ss&quot;</span>,<span class="st">&quot;a&quot;</span>,<span class="st">&quot;u&quot;</span>,<span class="st">&quot;g&quot;</span>,<span class="st">&quot;a&quot;</span>]</code></pre>
</div><div id="typeclasses-2" class="slide section level2">
<h1>Typeclasses</h1>
<ul>
<li>Haskell has various interesting typeclasses:
<ul>
<li><code>Monoid</code>s, <code>Functor</code>s, <code>Applicative</code>s, <code>Monad</code>s</li>
</ul></li>
<li>Each one is a very precise definition of what it means to be composable</li>
</ul>
<aside class="notes">
<ul>
<li>Comes from category theory in mathematics</li>
<li>We can use it anyway
</aside>
</li>
</ul>
</div>
<div id="the-monoid" class="titleslide slide section level1"><h1>The Monoid</h1></div><div id="the-monoid-1" class="slide section level2">
<h1>The Monoid</h1>
<ul>
<li>The Monoid is a simple typeclass</li>
<li>It decribes how to append two values of a datatype together</li>
</ul>
<blockquote>
&quot;In abstract algebra, a <strong>monoid</strong> is an algebraic structure with a single <strong>associative binary operation</strong> and an <strong>identity element</strong>.&quot; ― Wikipedia
</blockquote>

</div><div id="the-monoid-2" class="slide section level2">
<h1>The Monoid</h1>
<blockquote>
&quot;In abstract algebra, a <strong>monoid</strong> is an algebraic structure with a single <strong>associative binary operation</strong> and an <strong>identity element</strong>.&quot; ― Wikipedia
</blockquote>

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span>
<span class="ot">    mempty ::</span> a             <span class="co">-- identity</span>
<span class="ot">    mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a  <span class="co">-- binary operation</span>

<span class="co">-- Rules:  (not checked, but assumed in usage)</span>
<span class="co">-- identity</span>
mappend a mempty <span class="fu">=</span> a      
<span class="co">-- associativity</span>
mappend a (mappend b c) <span class="fu">=</span> mappend (mappend a b) c </code></pre>
<aside class="notes">
<ul>
<li>Don't worry about math jargon</li>
<li>Examples incoming
</aside>
</li>
</ul>
</div><div id="the-monoid-3" class="slide section level2">
<h1>The Monoid</h1>
<ul>
<li>You know lots of <code>Monoid</code>s!</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">String</span> <span class="kw">where</span>
    mempty <span class="fu">=</span> <span class="st">&quot;&quot;</span>            <span class="co">-- empty string is identity</span>
    mappend a b <span class="fu">=</span> a <span class="fu">++</span> b   <span class="co">-- op is string concatenation</span>

<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Int</span> <span class="kw">where</span>
    mempty <span class="fu">=</span> <span class="dv">0</span>
    mappend a b <span class="fu">=</span> a <span class="fu">+</span> b

<span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Set</span> a) <span class="kw">where</span>
    mempty <span class="fu">=</span> empty
    mappend s1 s2 <span class="fu">=</span> s1 <span class="ot">`union`</span> s2</code></pre>
</div><div id="mconcat" class="slide section level2">
<h1><code>mconcat</code></h1>
<ul>
<li>With a <code>Monoid</code> instance we get <code>mconcat</code> for free</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Accumulate a value from a list, using mappend</span>
<span class="ot">mconcat ::</span> (<span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> [m] <span class="ot">-&gt;</span> m</code></pre>
<ul>
<li>Can use it to sum numbers or concatenate a list of strings!</li>
<li>Union a list of Sets!</li>
<li>Join ethernet packets!</li>
<li>Combine Databases!</li>
</ul>
</div>
<div id="functors" class="titleslide slide section level1"><h1>Functors</h1></div><div id="problem" class="slide section level2">
<h1>Problem</h1>
<ul>
<li>You have a function <code>length :: String -&gt; Int</code></li>
<li>But you need to apply it to a list <code>[String]</code></li>
<li>What do you do?
<ul>
<li>Ideally want <code>someFunc :: [String] -&gt; [Int]</code></li>
</ul></li>
</ul>
</div><div id="map-4" class="slide section level2">
<h1>Map</h1>
<ul>
<li>We saw this before</li>
<li><code>map</code> a function over a list</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">map</span> <span class="fu">length</span> [<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;World!&quot;</span>]
[<span class="dv">5</span>, <span class="dv">6</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]</code></pre>
</div><div id="generalizing-map" class="slide section level2">
<h1>Generalizing map</h1>
<ul>
<li><code>map</code> applies a function to every element in a list</li>
<li>Or more interestingly...</li>
<li>It creates a new function that works on lists</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="fu">map</span>
<span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]

<span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="fu">map</span> <span class="fu">length</span>
<span class="fu">map</span><span class="ot"> length ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</code></pre>
</div><div id="lifting-functions" class="slide section level2">
<h1>Lifting functions</h1>
<p>With <code>map</code> we <em>lift</em> a function to work with lists</p>
<figure>
<object width="100%" data="diagrams/LiftingLength.svg" type="image/svg+xml">
    
<img src="diagrams/LiftingLength.png" />
</object>
</figure>

</div><div id="lifting-functions-1" class="slide section level2">
<h1>Lifting functions</h1>
<p>Generalizing to arbitrary types <code>a</code> and <code>b</code></p>
<figure>
<object width="100%" data="diagrams/Map.svg" type="image/svg+xml">
    
<img src="diagrams/Map.png" />
</object>
</figure>

</div><div id="key-insight" class="slide section level2">
<h1>Key insight</h1>
<ul>
<li>Have two <em>vertical</em> types of arrows:
<ul>
<li>object to object
<ul>
<li>wrap inside list with <code>[]</code></li>
</ul></li>
<li>function to function
<ul>
<li>using <code>map</code> to <em>lift</em> other functions</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>Question: Given an arbitrary type wrapper, can we come up with a unique <em>lifting</em> function?</p>
</blockquote>
<p>TODO: give another motivating example in the form of <code>Maybe</code>?</p>
</div><div id="functors-1" class="slide section level2">
<h1>Functors</h1>
<figure>
<object width="100%" data="diagrams/Functors.svg" type="image/svg+xml">
    
<img src="diagrams/Functors.png" />
</object>
</figure>

</div><div id="functor-composition" class="slide section level2">
<h1>Functor Composition</h1>
<figure>
<object width="100%" data="diagrams/FunctorComposition.svg" type="image/svg+xml">
    
<img src="diagrams/FunctorComposition.png" />
</object>
</figure>

</div>
<div id="monads" class="titleslide slide section level1"><h1>Monads</h1></div><div id="monads-1" class="slide section level2">
<h1>Monads</h1>
<figure>
<object width="100%" data="diagrams/Endofunctors.svg" type="image/svg+xml">
    
<img src="diagrams/Endofunctors.png" />
</object>
</figure>

</div>
<div id="scrap" class="titleslide slide section level1"><h1>Scrap</h1></div><div id="outline-of-topics" class="slide section level2">
<h1>Outline of topics</h1>
<p>Need some kind of goal</p>
<ul>
<li>Value assignments</li>
<li>Add/subtract</li>
<li>Types</li>
<li>Lists</li>
<li>Strings</li>
<li>Functions</li>
</ul>
</div><div id="ideas-for-small-programs" class="slide section level2">
<h1>Ideas for small programs</h1>
<ul>
<li>converting bank hex files to single binary file</li>
</ul>
</div><div id="wip-benefits-of-lazy-evaluation" class="slide section level2">
<h1>WIP Benefits of Lazy Evaluation</h1>
<ul>
<li>Allows heavy reuse of code</li>
<li>Give example of filtering a list</li>
<li>fold, map, filter</li>
</ul>
</div><div id="syntax-overview" class="slide section level2">
<h1>Syntax Overview</h1>
<ul>
<li><code>=</code> -- Define a value</li>
<li><code>::</code> -- Type annotation</li>
<li><code>[1, 2, 3]</code> -- List</li>
<li><code>:</code> -- Prepend to a list</li>
<li><code>++</code> -- Concatenate two lists</li>
<li><code>a -&gt; b</code> -- Function from <code>a</code> to <code>b</code></li>
<li><code>where</code> -- scoped definition</li>
</ul>
</div><div id="syntax-overview-1" class="slide section level2">
<h1>Syntax Overview</h1>
<table>
<thead>
<tr class="header">
<th align="left">Syntax</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x = 42</code></td>
<td align="left">Define a value</td>
</tr>
<tr class="even">
<td align="left"><code>42 :: Int</code></td>
<td align="left">Type annotation</td>
</tr>
<tr class="odd">
<td align="left"><code>a -&gt; b</code></td>
<td align="left">Function from <code>a</code> to <code>b</code></td>
</tr>
<tr class="even">
<td align="left"><code>[1, 2, 3]</code></td>
<td align="left">List</td>
</tr>
<tr class="odd">
<td align="left"><code>1 : [2, 3]</code></td>
<td align="left">Prepend to a list</td>
</tr>
<tr class="even">
<td align="left"><code>&quot;He&quot; ++ &quot;llo&quot;</code></td>
<td align="left">Concatenate two lists</td>
</tr>
<tr class="odd">
<td align="left"><code>where</code></td>
<td align="left">scoped definition</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>
