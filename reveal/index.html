<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Haskell Introduction</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Alexander Kondratskiy">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/moon.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/monokai_sublime.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

<section><section id="haskell" class="titleslide slide level1"><h1>HASKELL</h1></section><section id="first-language" class="slide level2">
<h1>First Language</h1>
<blockquote>
“The most disastrous thing that you can ever learn is your first programming language.” ― Alan Kay (pioneer in OOP)
</blockquote>

<ul>
<li>First programming language shapes habits, limits thinking
<ul>
<li>Overuse of <code>new</code> in C++ coming from Java</li>
<li>Indexed <code>for</code> loops in Python coming from C</li>
</ul></li>
<li>Good to &quot;grok&quot; others to gain perspective</li>
</ul>
</section><section id="haskell-1" class="slide level2">
<h1>Haskell</h1>
<ul>
<li>Haskell is unlike any other language</li>
<li>Language Design decisions oppose the status quo
<ul>
<li>But brilliantly so</li>
</ul></li>
<li>Many advantages gained as a result
<ul>
<li>Plus, it's fun to program again!</li>
</ul></li>
</ul>
<figure>
<img src="images/HaskellLogo.jpg" />
</figure>
</section><section id="quicksort" class="slide level2">
<h1>QuickSort</h1>
<pre class="haskell"><code>quicksort :: Ord a =&gt; [a] -&gt; [a]
quicksort []     = []
quicksort (p:xs) =
    (quicksort lesser) ++ [p] ++ (quicksort greater)
    where
        lesser  = filter (&lt; p) xs
        greater = filter (&gt;= p) xs</code></pre>
<aside class="notes">

<ul>
<li>High level</li>
<li>Declarative</li>
<li><p>Elegant</p></li>
<li>No variable assignments</li>
<li>Breaks into cases
</aside>
</li>
</ul>
</section><section id="haskell-platform" class="slide level2">
<h1>Haskell Platform</h1>
<p>Cross-platform distribution with trusted libraries</p>
<p><a href="http://hackage.haskell.org/platform"><img src="http://hackage.haskell.org/platform/icons/button-100.png" alt="Download Haskell Platform" /></a></p>
</section><section id="hackage" class="slide level2">
<h1>Hackage</h1>
<p>Rich open source library repository</p>
</section><section id="cabal" class="slide level2">
<h1>Cabal</h1>
<p>Package management</p>
<p><a href="https://github.com/haskell/cabal/wiki/cabal-install"><img src="http://hackage.haskell.org/images/Cabal-dark.png" /></a></p>
</section><section id="ghc" class="slide level2">
<h1>GHC</h1>
<p>Glasgow Haskell Compiler</p>
</section><section id="ghci" class="slide level2">
<h1>GHCi</h1>
<p>Interpreter</p>
</section><section id="hoogle" class="slide level2">
<h1>Hoogle</h1>
<p>Search yours and other's libraries by type signatures</p>
<p><a href="http://www.haskell.org/hoogle/"><img src="http://www.haskell.org/hoogle/res/hoogle.png" /></a></p>
</section><section id="school-of-haskell" class="slide level2">
<h1>School Of Haskell</h1>
<p>In-depth tutorials with inline runable/editable code</p>
<p><a href="https://www.fpcomplete.com/school"><img src="https://www.gravatar.com/avatar/76a473697ce9ed86d1d1ef514abbd5b8?s=200" alt="School Of Haskell" /></a></p>
</section><section id="other-cool-stuff" class="slide level2">
<h1>Other Cool Stuff</h1>
<ul>
<li><a href="http://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a>
<ul>
<li>Generates test cases</li>
<li>Provides <em>minimal</em> failing test case on failure</li>
</ul></li>
<li><a href="https://www.fpcomplete.com/school/beautiful-concurrency">Software Transaction Memory</a>
<ul>
<li>Composable concurrency abstraction</li>
</ul></li>
</ul>
</section><section id="haskell-2" class="slide level2">
<h1>Haskell</h1>
<p>More formally...</p>
<blockquote>
Haskell is a purely functional, statically typed programming language, with non-strict evaluation.
</blockquote>

</section><section id="wat" class="slide level2">
<h1><strong>WAT</strong></h1>
</section></section>
<section><section id="the-language" class="titleslide slide level1"><h1>The Language</h1></section><section id="the-language-1" class="slide level2">
<h1>The Language</h1>
<ul>
<li>Purely functional
<ul>
<li>Pure - no side effects!</li>
<li>Functional - functions are first-class values!</li>
</ul></li>
<li>Statically typed
<ul>
<li>Rich type system</li>
<li>Inference engine</li>
<li>Type polymorphism, Kinds, Kind Polymorphism</li>
</ul></li>
<li>Non-strict evaluation
<ul>
<li>A.k.a. lazy evaluation</li>
</ul></li>
</ul>
</section><section id="pure" class="slide level2">
<h1>Pure</h1>
<blockquote>
<p>Applying a function with the same parameters always returns the same value</p>
</blockquote>
</section><section id="pure-1" class="slide level2">
<h1>Pure</h1>
<ul>
<li>Functions are functions in the <em>mathematical</em> sense</li>
<li>No side effects within functions
<ul>
<li>No mutation, assignment or implicit state</li>
<li>Everything is immutable</li>
<li>No IO</li>
<li>No global state</li>
</ul></li>
</ul>
</section><section id="pure-2" class="slide level2">
<h1>Pure</h1>
<ul>
<li>Functions are referentially transparent
<ul>
<li>Repeatable results</li>
<li>Great for testing</li>
</ul></li>
<li>Allows for pervasive sharing
<ul>
<li>If everything immutable, no worry about mutation</li>
<li>Concurrency/Parallelism is trivial</li>
</ul></li>
</ul>
</section><section id="pure-3" class="slide level2">
<h1>Pure</h1>
<ul>
<li>Some intuition: Excel Spreadsheet
<ul>
<li>User-specified cells are inputs</li>
<li>Formula cells are outputs</li>
<li>Cells are not updated as state by Excel</li>
<li>Can be easily parallelized</li>
</ul></li>
</ul>
<p>TODO: Excel picture</p>
</section><section id="functional" class="slide level2">
<h1>Functional</h1>
<blockquote>
<p>Functions are first-class values</p>
</blockquote>
</section><section id="functional-1" class="slide level2">
<h1>Functional</h1>
<ul>
<li>Functions are first-class values
<ul>
<li>Can be passed around</li>
<li>Can be defined inline (lambda functions)</li>
</ul></li>
<li>Higher-order functions
<ul>
<li>Functions that return new functions</li>
</ul></li>
</ul>
</section><section id="functional-2" class="slide level2">
<h1>Functional</h1>
<ul>
<li>Limited intuition in imperative languages:
<ul>
<li><code>qsort</code> from C</li>
</ul></li>
</ul>
<pre class="cpp"><code>void qsort(
    void *ptr,
    size_t count,
    size_t size,
    // function as a parameter
    int (*comp)(const void *, const void *)
);</code></pre>
<aside class="notes">
    
<ul>
<li>Function pointers not a closure
<ul>
<li>Can't return a new function
</aside>
</li>
</ul></li>
</ul>
</section><section id="lazy" class="slide level2">
<h1>Lazy</h1>
<blockquote>
<p>Values evaluated only when needed</p>
</blockquote>
</section><section id="lazy-1" class="slide level2">
<h1>Lazy</h1>
<ul>
<li>Lazy by default</li>
<li>Evaluates values when they are needed</li>
</ul>
</section><section id="lazy-2" class="slide level2">
<h1>Lazy</h1>
<ul>
<li>Some intuition:
<ul>
<li>Short circuiting of boolean expressions</li>
</ul></li>
</ul>
<pre class="cpp"><code>if (pointer != NULL &amp;&amp; pointer-&gt;doesSomething())
{
    // ...
}
else if (number &lt; 0 || number &gt; 100)
{
    // ...
}</code></pre>
</section><section id="haskell-philosophy" class="slide level2">
<h1>Haskell Philosophy</h1>
<ul>
<li>&quot;What&quot; rather than &quot;How&quot;</li>
<li>Data flow</li>
<li>Purity</li>
<li>Composition</li>
</ul>
</section></section>
<section><section id="syntax-intro" class="titleslide slide level1"><h1>Syntax Intro</h1></section><section id="defining-values" class="slide level2">
<h1>Defining Values</h1>
<pre class="haskell"><code>-- define a value
x = 42
-- cannot reassign x = 7

-- functions are also values
addOneTo v = v + 1</code></pre>
<ul>
<li><code>=</code> is Mathematical Equality</li>
<li><em>Not</em> assignment</li>
<li>Both sides are <em>equivalent</em>
<ul>
<li>Left can be substituted by right</li>
<li>And vice versa</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Mention cannot reassign - not a VARiable</li>
<li>Functions are values just like integers
</aside>
</li>
</ul>
</section><section id="type-annotations" class="slide level2">
<h1>Type annotations</h1>
<pre class="haskell"><code>x :: Int
x = 5

y :: Double
y = 4.2

addOneTo :: Int -&gt; Int
addOneTo v = v + 1</code></pre>
<ul>
<li>Everything has a type</li>
<li><code>::</code> allows us to annotate values with types</li>
<li>Concrete types always <em>Capitalized</em></li>
<li><code>a -&gt; b</code> denotes a function from <code>a</code> to <code>b</code></li>
</ul>
</section><section id="function-application" class="slide level2">
<h1>Function application</h1>
<pre class="haskell"><code>six :: Int
six = addOneTo 5

main :: IO ()
main = print six</code></pre>
</section><section id="new-data-types" class="slide level2">
<h1>New Data types</h1>
<ul>
<li>We have seen some types</li>
<li>Let's see the <code>Bool</code> definition</li>
</ul>
<pre class="haskell"><code>--   \/~~ new type name
data Bool = True | False
--           /\     /\
--   Possible values in type</code></pre>
</section><section id="pattern-matching" class="slide level2">
<h1>Pattern Matching</h1>
<ul>
<li>We can inspect structure of arguments in function definitions
<ul>
<li>Called Pattern Matching</li>
</ul></li>
</ul>
<pre class="haskell"><code>-- Using built-in if
boolToString :: Bool -&gt; String
boolToString b = if b then &quot;Yes!&quot; else &quot;No!&quot;

-- Using Pattern Matching
boolToString&#39; :: Bool -&gt; String
boolToString&#39; True  = &quot;Yes!&quot;
boolToString&#39; False = &quot;No!&quot;</code></pre>
<aside class="notes">
<ul>
<li>&quot;Unpacking&quot; the argument
</aside>
</li>
</ul>
</section><section id="factorial-example" class="slide level2">
<h1>Factorial Example</h1>
<pre class="haskell"><code>-- Pattern matching and recursion
factorial :: Int -&gt; Int
factorial 0 = 1
factorial n = n * factorial (n - 1)</code></pre>
<aside class="notes">
<ul>
<li>Mention <code>data Int =</code>1 | 2 | 3 | 4 ...`
</aside>
</li>
</ul>
</section><section id="lists" class="slide level2">
<h1>Lists</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Syntax</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>[]</code></td>
<td style="text-align: left;">Empty List</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[1, 2, 3]</code></td>
<td style="text-align: left;">List</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1 : [2, 3]</code></td>
<td style="text-align: left;">Prepend to a list</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[1, 2] ++ [3, 4]</code></td>
<td style="text-align: left;">Concatenate two lists</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&quot;Hello&quot; :: [Char]</code></td>
<td style="text-align: left;">Strings are lists of <code>Char</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&quot;He&quot; ++ &quot;llo&quot;</code></td>
<td style="text-align: left;">Concatenate two strings</td>
</tr>
</tbody>
</table>
</section><section id="list-operations" class="slide level2">
<h1>List operations</h1>
<p>Pattern match on <code>:</code> construction.</p>
<pre class="haskell"><code>-- Get first element
head :: [a] -&gt; a
head (x:xs) = x</code></pre>
<pre class="haskell"><code>-- Get list after first element
tail :: [a] -&gt; [a]
tail []     = []
tail (x:xs) = xs</code></pre>
<aside class="notes">
<ul>
<li>Pattern match against list construction <code>:</code></li>
<li>Parametric polymorphism</li>
<li>We don't assume anything about list elements themselves</li>
<li>Cover empty case</li>
<li>mention <code>error &quot;empty list&quot;</code> only if asked
</aside>
</li>
</ul>
</section><section id="reverse-a-list" class="slide level2">
<h1>Reverse a List</h1>
<p>Pattern matching is your friend</p>
<pre class="haskell"><code>myReverse :: [a] -&gt; [a]
myReverse [] = []
myReverse (x:xs) = myReverse xs ++ [x]</code></pre>
<p>Reuse <code>head</code> and <code>tail</code>:</p>
<pre class="haskell"><code>myReverse :: [a] -&gt; [a]
myReverse [] = []
myReverse list = myReverse (tail list) ++ [head list]</code></pre>
<aside class="notes">
<ul>
<li>Can make it more generic
</aside>
</li>
</ul>
</section></section>
<section><section id="function-example" class="titleslide slide level1"><h1>Function Example</h1></section><section id="summing-a-list" class="slide level2">
<h1>Summing a list</h1>
<pre class="haskell"><code>mySum :: [Int] -&gt; Int
mySum []     = 0
mySum (x:xs) = x + (mySum xs)</code></pre>
</section><section id="substitution" class="slide level2">
<h1>Substitution</h1>
<p>Let's evaluate <code>mySum</code> on a small list, by following substitution rules</p>
<pre class="haskell"><code>-- mySum []     = 0
-- mySum (x:xs) = x + (mySum xs)
  mySum [1,2,3]
= mySum 1:[2,3]
= 1 + (mySum [2,3])
= 1 + (mySum 2:[3])
= 1 + ( 2 + (mySum [3]))
= 1 + ( 2 + (mySum 3:[]))
= 1 + ( 2 + ( 3 + (mySum [])))
= 1 + ( 2 + ( 3 + (0)))
= 1 + ( 2 + ( 3 ))
= 1 + ( 5 )
= 6</code></pre>
<p>Inefficient: requires O(n) space!</p>
</section><section id="tail-recursion" class="slide level2">
<h1>Tail Recursion</h1>
<ul>
<li>Can we use O(1) space?</li>
<li>Use tail recursion to implement a new sum function:</li>
</ul>
<pre class="haskell"><code>-- Takes an accumulator as first argument
mySum&#39; :: Int -&gt; [Int] -&gt; Int
mySum&#39; acc []     = acc
mySum&#39; acc (x:xs) = mySum&#39; (acc + x) xs
-- ^ add the head of the list to the accumulator</code></pre>
<ul>
<li>No computation to be done after recursive call</li>
<li>Essentially replace the current context with recursive call</li>
</ul>
</section><section id="tail-recursion-1" class="slide level2">
<h1>Tail Recursion</h1>
<p>To see why this takes constant space, let's use substitution rules:</p>
<pre class="haskell"><code>-- mySum&#39; acc []     = acc
-- mySum&#39; acc (x:xs) = mySum&#39; (acc + x) xs
  mySum&#39; 0     [1,2,3]
= mySum&#39; 0     1:[2,3]
= mySum&#39; (0+1) [2,3]
= mySum&#39; 1     2:[3]
= mySum&#39; (1+2) [3]
= mySum&#39; 3     3:[]
= mySum&#39; (3+3) []
= mySum&#39; 6     []
= 6</code></pre>
<p>This is equivalent to a flat loop in an imperative language.</p>
</section><section id="tail-recursion-2" class="slide level2">
<h1>Tail Recursion</h1>
<ul>
<li>Let's encapsulate this accumulator implementation</li>
<li>Use <code>where</code> for scoped definitions</li>
</ul>
<pre class="haskell"><code>mySum :: [Int] -&gt; Int
-- call implementation with 0 accumulator
mySum xs = mySum&#39; 0   xs
     where mySum&#39; acc []     = acc
           mySum&#39; acc (x:xs) = mySum&#39; (acc + x) xs</code></pre>
</section><section id="towards-reusability" class="slide level2">
<h1>Towards Reusability</h1>
<ul>
<li>The type signature of <code>mySum</code> is quite restrictive</li>
<li>We may want to sum
<ul>
<li><code>Float</code>s</li>
<li><code>Double</code>s</li>
<li><code>Complex</code> numbers</li>
</ul></li>
<li>Can we make it generic?</li>
</ul>
</section></section>
<section><section id="type-inference" class="titleslide slide level1"><h1>Type Inference</h1></section><section id="type-inference-1" class="slide level2">
<h1>Type Inference</h1>
<ul>
<li>The compiler can infer types</li>
<li>We can neglect type signatures</li>
</ul>
<pre class="haskell"><code>-- Compiles without type signature!
mySum xs = mySum&#39; 0   xs
     where mySum&#39; acc []     = acc
           mySum&#39; acc (x:xs) = mySum&#39; (acc + x) xs</code></pre>
<ul>
<li>And ask the compiler what it thinks:</li>
</ul>
<pre class="haskell"><code>-- Query the type in interpreter
&gt; :type mySum
mySum :: Num a =&gt; [a] -&gt; a</code></pre>
</section><section id="type-inference---how" class="slide level2">
<h1>Type Inference - How?</h1>
<pre class="haskell"><code>--  Says &quot;Type parameter a has to be a Number&quot;
mySum :: Num a =&gt; [a] -&gt; a
mySum xs = mySum&#39; 0   xs
     where mySum&#39; acc []     = acc
           mySum&#39; acc (x:xs) = mySum&#39; (acc + x) xs
--                the clue to the compiler ^</code></pre>
<ul>
<li>The compiler looks at what we have used:
<ul>
<li>Elements combined with operator <code>+</code></li>
</ul></li>
<li>The &quot;interface&quot; that exposes <code>+</code> is <code>Num</code></li>
<li>Therefore <code>mySum</code> can only be used on lists of <code>Num</code>s</li>
</ul>
</section><section id="type-inference-2" class="slide level2">
<h1>Type Inference</h1>
<ul>
<li>Let's try on different types:</li>
</ul>
<pre class="haskell"><code>&gt; mySum [1, 2, 3, 4, 5, 6, 7]
28 :: Int

&gt; mySum [2.5, 3.5, 4.5, 5.5, 6.5, 7.5]
30.0 :: Double</code></pre>
</section><section id="type-inference---benefits" class="slide level2">
<h1>Type Inference - Benefits</h1>
<ul>
<li>Compiler infers most generic type</li>
<li>Genericity for free</li>
<li>Type annotations more useful to programmers than compiler</li>
</ul>
<aside class="notes">
<ul>
<li>Mention UML
</aside>
</li>
</ul>
</section></section>
<section><section id="control-structures" class="titleslide slide level1"><h1>Control Structures</h1></section><section id="control-structures-1" class="slide level2">
<h1>Control Structures</h1>
<ul>
<li>Are there really no control structures?
<ul>
<li><code>if</code> ?</li>
<li><code>while</code> ?</li>
<li><code>for</code> ?</li>
</ul></li>
<li>We can construct our own!
<ul>
<li>Due to Haskell's laziness</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Imperative control structures awkward in functional setting</li>
<li>Better alternatives exist
</aside>
</li>
</ul>
</section></section>
<section><section id="abstracting-loops" class="titleslide slide level1"><h1>Abstracting loops</h1></section><section id="abstracting-loops-1" class="slide level2">
<h1>Abstracting loops</h1>
<ul>
<li>For loops are very low level
<ul>
<li>No inherent semantics</li>
</ul></li>
<li>Transforming a list - <code>map</code></li>
<li>Accumulating over a list - <code>fold</code></li>
</ul>
</section><section id="map" class="slide level2">
<h1>Map</h1>
<pre class="haskell"><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code></pre>
<p><code>map f xs</code> is the list obtained by applying f to each element of xs, i.e.,</p>
<pre class="haskell"><code>&gt; map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
&gt; map f [x1, x2, ...] == [f x1, f x2, ...] </code></pre>
</section><section id="map-1" class="slide level2">
<h1>Map</h1>
<ul>
<li>Map works by applying another function over a list</li>
<li>We have to pass a function to map
<ul>
<li>Similar to C's <code>qsort</code></li>
</ul></li>
</ul>
</section><section id="map-2" class="slide level2">
<h1>Map</h1>
<figure>
<object width="100%" data="diagrams/MapFunction.svg" type="image/svg+xml">
    
<img src="diagrams/MapFunction.png" />
</object>
</figure>

</section><section id="map-3" class="slide level2">
<h1>Map</h1>
<pre class="haskell"><code>&gt; map (*2) [1, 2, 3, 4, 5]
[2, 4, 6, 8, 10]</code></pre>
<figure>
<object width="100%" data="diagrams/MapTimesTwo.svg" type="image/svg+xml">
    
<img src="diagrams/MapTimesTwo.png" />
</object>
</figure>

<aside class="notes">
<ul>
<li>Mention <code>std::transform</code> equivalent in stl
</aside>

</li>
</ul>
</section><section id="functions" class="slide level2">
<h1>Functions</h1>
<p>TODO: functions</p>
<ul>
<li>Functions are first class values!
<ul>
<li>Can be passed around</li>
<li>Can be equaded</li>
<li>Can be created</li>
</ul></li>
</ul>
</section><section id="functions---passed-around" class="slide level2">
<h1>Functions - Passed Around</h1>
<ul>
<li>Accumulating over a list is abstracted as a &quot;fold&quot;</li>
</ul>
<pre class="haskell"><code>foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
--       ~~~~~~~~~~~~~    ^- starting value (accumulator)
--      binary operator</code></pre>
<blockquote>
<p>foldl, applied to a <strong>binary operator</strong>, a <strong>starting value</strong> (typically the left-identity of the operator), and <strong>a list</strong>, reduces the list using the binary operator, from left to right.</p>
</blockquote>
<p>TODO: diagram of foldl?</p>
</section><section id="functions---passed-around-1" class="slide level2">
<h1>Functions - Passed Around</h1>
<ul>
<li>Accumulating over a list is abstracted as a &quot;fold&quot;</li>
</ul>
<pre class="haskell"><code>foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
(+)   :: Num a =&gt; a -&gt; a -&gt; a

mySum xs = foldl (+) 0 xs</code></pre>
</section><section id="functions---created" class="slide level2">
<h1>Functions - Created</h1>
<pre class="haskell"><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]

doubleValues xs = map (\x -&gt; x * 2) xs
--                    ~^~~~~~~~~~~~
--                   lambda function</code></pre>
<pre class="haskell"><code>&gt; doubleValues [1..5]
[2, 4, 6, 8, 10]</code></pre>
</section><section id="functions---equaded" class="slide level2">
<h1>Functions - Equaded</h1>
<ul>
<li>Functions are values</li>
<li>Values can be defined in terms of other values</li>
<li>Define one function by equading to another
<ul>
<li>This is called <em>pointfree</em> notation</li>
</ul></li>
</ul>
<pre class="haskell"><code>toUpper :: Char -&gt; Char
map     :: (a -&gt; b) -&gt; [a] -&gt; [b]

stringToUpper :: String -&gt; String
stringToUpper s = map (toUpper) s

-- factor out s
stringToUpper&#39; :: String -&gt; String
stringToUpper&#39; = map (toUpper)</code></pre>
</section><section id="functions---equaded-1" class="slide level2">
<h1>Functions - Equaded</h1>
<pre class="haskell"><code>stringToUpper :: String -&gt; String
stringToUpper = map (toUpper) </code></pre>
<pre class="haskell"><code>&gt; stringToUpper &quot;Hello World&quot;
&quot;HELLO WORLD&quot;</code></pre>
</section><section id="more-reusability" class="slide level2">
<h1>More Reusability?</h1>
<ul>
<li>Our <code>mySum</code> function works great for adding a list of numbers</li>
<li>But more types can be aggregated:
<ul>
<li>e.g. <code>String</code>s</li>
</ul></li>
<li>Can we capture this behaviour in an &quot;interface&quot;?</li>
</ul>
</section></section>
<section><section id="typeclasses" class="titleslide slide level1"><h1>Typeclasses</h1></section><section id="typeclasses-1" class="slide level2">
<h1>Typeclasses</h1>
<ul>
<li>Typeclasses are the &quot;interfaces&quot; of Haskell</li>
<li>Much more flexible and general</li>
</ul>
<pre class="haskell"><code>-- The Num typeclass we saw before
class Num a where
    (+) :: a -&gt; a -&gt; a
    (*) :: a -&gt; a -&gt; a
    (-) :: a -&gt; a -&gt; a
    negate :: a -&gt; a
    abs :: a -&gt; a</code></pre>
<ul>
<li>Anything can be treated as a number as long as it defines the above functions</li>
</ul>
</section><section id="typeclasses---instances" class="slide level2">
<h1>Typeclasses - Instances</h1>
<ul>
<li>A Data Type can adhere to a typeclass by specifying an <code>instance</code></li>
<li>Attach behaviour after the fact onto existing Data Type</li>
</ul>
<p>TODO: &quot;filling in the 'a' &quot;</p>
<pre class="haskell"><code>instance Num Int where
    (+) = intSum  -- assuming intSum
    (*) = intMult --          intMult
    (-) = intSub  --          intSub are provided elsewhere
    negate x =  0 - x
    abs x = if x &lt; 0
            then negate x
            else x</code></pre>
</section><section id="more-typeclasses" class="slide level2">
<h1>More Typeclasses</h1>
<pre class="haskell"><code>class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool

class Eq a =&gt; Ord a where
    -- minimal definition requires compare
    -- the rest are automatically defined in terms of it
    compare :: a -&gt; a -&gt; Ordering
    (&lt;)  :: a -&gt; a -&gt; Bool
    (&gt;=) :: a -&gt; a -&gt; Bool
    (&gt;)  :: a -&gt; a -&gt; Bool
    (&lt;=) :: a -&gt; a -&gt; Bool
    max  :: a -&gt; a -&gt; a
    min  :: a -&gt; a -&gt; a</code></pre>
</section><section id="generic-functions" class="slide level2">
<h1>Generic functions</h1>
<ul>
<li>Typeclasses decouple behaviour and polymorphism from data.</li>
<li>Wealth of reusable functions to be used</li>
</ul>
<pre class="haskell"><code>sort :: Ord a =&gt; [a] -&gt; [a]
-- example:
sort &quot;Missisauga&quot; = &quot;Maagiissssu&quot;

group :: Eq a =&gt; [a] -&gt; [[a]]
-- example:
group &quot;Missisauga&quot; = [&quot;M&quot;,&quot;i&quot;,&quot;ss&quot;,&quot;i&quot;,&quot;ss&quot;,&quot;a&quot;,&quot;u&quot;,&quot;g&quot;,&quot;a&quot;]</code></pre>
</section><section id="typeclasses-2" class="slide level2">
<h1>Typeclasses</h1>
<ul>
<li>Haskell has various interesting typeclasses:
<ul>
<li><code>Monoid</code>s, <code>Functor</code>s, <code>Applicative</code>s, <code>Monad</code>s</li>
</ul></li>
<li>Each one is a very precise definition of what it means to be composable</li>
</ul>
<aside class="notes">
<ul>
<li>Comes from category theory in mathematics</li>
<li>We can use it anyway
</aside>
</li>
</ul>
</section></section>
<section><section id="the-monoid" class="titleslide slide level1"><h1>The Monoid</h1></section><section id="the-monoid-1" class="slide level2">
<h1>The Monoid</h1>
<ul>
<li>The Monoid is a simple typeclass</li>
<li>It decribes how to append two values of a datatype together</li>
</ul>
<blockquote>
&quot;In abstract algebra, a <strong>monoid</strong> is an algebraic structure with a single <strong>associative binary operation</strong> and an <strong>identity element</strong>.&quot; ― Wikipedia
</blockquote>

</section><section id="the-monoid-2" class="slide level2">
<h1>The Monoid</h1>
<blockquote>
&quot;In abstract algebra, a <strong>monoid</strong> is an algebraic structure with a single <strong>associative binary operation</strong> and an <strong>identity element</strong>.&quot; ― Wikipedia
</blockquote>

<pre class="haskell"><code>class Monoid a where
    mempty :: a             -- identity
    mappend :: a -&gt; a -&gt; a  -- binary operation

-- Rules:  (not checked, but assumed in usage)
-- identity
mappend a mempty = a      
-- associativity
mappend a (mappend b c) = mappend (mappend a b) c </code></pre>
<aside class="notes">
<ul>
<li>Don't worry about math jargon</li>
<li>Examples incoming
</aside>
</li>
</ul>
</section><section id="the-monoid-3" class="slide level2">
<h1>The Monoid</h1>
<ul>
<li>You know lots of <code>Monoid</code>s!</li>
</ul>
<pre class="haskell"><code>instance Monoid String where
    mempty = &quot;&quot;            -- empty string is identity
    mappend a b = a ++ b   -- op is string concatenation

instance Monoid Int where
    mempty = 0
    mappend a b = a + b

instance Monoid (Set a) where
    mempty = empty
    mappend s1 s2 = s1 `union` s2</code></pre>
</section><section id="mconcat" class="slide level2">
<h1><code>mconcat</code></h1>
<ul>
<li>With a <code>Monoid</code> instance we get <code>mconcat</code> for free</li>
</ul>
<pre class="haskell"><code>-- Accumulate a value from a list, using mappend
mconcat :: (Monoid m) =&gt; [m] -&gt; m</code></pre>
<ul>
<li>Can use it to sum numbers or concatenate a list of strings!</li>
<li>Union a list of Sets!</li>
<li>Join ethernet packets!</li>
<li>Combine Databases!</li>
</ul>
</section></section>
<section><section id="functors" class="titleslide slide level1"><h1>Functors</h1></section><section id="problem" class="slide level2">
<h1>Problem</h1>
<ul>
<li>You have a function <code>length :: String -&gt; Int</code></li>
<li>But you need to apply it to a list <code>[String]</code></li>
<li>What do you do?
<ul>
<li>Ideally want <code>someFunc :: [String] -&gt; [Int]</code></li>
</ul></li>
</ul>
</section><section id="map-4" class="slide level2">
<h1>Map</h1>
<ul>
<li>We saw this before</li>
<li><code>map</code> a function over a list</li>
</ul>
<pre class="haskell"><code>&gt; map length [&quot;Hello&quot;, &quot;World!&quot;]
[5, 6] :: [Int]</code></pre>
</section><section id="generalizing-map" class="slide level2">
<h1>Generalizing map</h1>
<ul>
<li><code>map</code> applies a function to every element in a list</li>
<li>Or more interestingly...</li>
<li>It creates a new function that works on lists</li>
</ul>
<pre class="haskell"><code>&gt; :type map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]

&gt; :type map length
map length :: [String] -&gt; [Int]</code></pre>
</section><section id="lifting-functions" class="slide level2">
<h1>Lifting functions</h1>
<p>With <code>map</code> we <em>lift</em> a function to work with lists</p>
<figure>
<object width="100%" data="diagrams/LiftingLength.svg" type="image/svg+xml">
    
<img src="diagrams/LiftingLength.png" />
</object>
</figure>

</section><section id="lifting-functions-1" class="slide level2">
<h1>Lifting functions</h1>
<p>Generalizing to arbitrary types <code>a</code> and <code>b</code></p>
<figure>
<object width="100%" data="diagrams/Map.svg" type="image/svg+xml">
    
<img src="diagrams/Map.png" />
</object>
</figure>

</section><section id="key-insight" class="slide level2">
<h1>Key insight</h1>
<ul>
<li>Have two <em>vertical</em> types of arrows:
<ul>
<li>object to object
<ul>
<li>wrap inside list with <code>[]</code></li>
</ul></li>
<li>function to function
<ul>
<li>using <code>map</code> to <em>lift</em> other functions</li>
</ul></li>
</ul></li>
</ul>
<blockquote>
<p>Question: Given an arbitrary type wrapper, can we come up with a unique <em>lifting</em> function?</p>
</blockquote>
<p>TODO: give another motivating example in the form of <code>Maybe</code>?</p>
</section><section id="functors-1" class="slide level2">
<h1>Functors</h1>
<figure>
<object width="100%" data="diagrams/Functors.svg" type="image/svg+xml">
    
<img src="diagrams/Functors.png" />
</object>
</figure>

</section><section id="functor-composition" class="slide level2">
<h1>Functor Composition</h1>
<figure>
<object width="100%" data="diagrams/FunctorComposition.svg" type="image/svg+xml">
    
<img src="diagrams/FunctorComposition.png" />
</object>
</figure>

</section></section>
<section><section id="monads" class="titleslide slide level1"><h1>Monads</h1></section><section id="monads-1" class="slide level2">
<h1>Monads</h1>
<figure>
<object width="100%" data="diagrams/Endofunctors.svg" type="image/svg+xml">
    
<img src="diagrams/Endofunctors.png" />
</object>
</figure>

</section></section>
<section><section id="scrap" class="titleslide slide level1"><h1>Scrap</h1></section><section id="outline-of-topics" class="slide level2">
<h1>Outline of topics</h1>
<p>Need some kind of goal</p>
<ul>
<li>Value assignments</li>
<li>Add/subtract</li>
<li>Types</li>
<li>Lists</li>
<li>Strings</li>
<li>Functions</li>
</ul>
</section><section id="ideas-for-small-programs" class="slide level2">
<h1>Ideas for small programs</h1>
<ul>
<li>converting bank hex files to single binary file</li>
</ul>
</section><section id="wip-benefits-of-lazy-evaluation" class="slide level2">
<h1>WIP Benefits of Lazy Evaluation</h1>
<ul>
<li>Allows heavy reuse of code</li>
<li>Give example of filtering a list</li>
<li>fold, map, filter</li>
</ul>
</section><section id="syntax-overview" class="slide level2">
<h1>Syntax Overview</h1>
<ul>
<li><code>=</code> -- Define a value</li>
<li><code>::</code> -- Type annotation</li>
<li><code>[1, 2, 3]</code> -- List</li>
<li><code>:</code> -- Prepend to a list</li>
<li><code>++</code> -- Concatenate two lists</li>
<li><code>a -&gt; b</code> -- Function from <code>a</code> to <code>b</code></li>
<li><code>where</code> -- scoped definition</li>
</ul>
</section><section id="syntax-overview-1" class="slide level2">
<h1>Syntax Overview</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Syntax</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>x = 42</code></td>
<td style="text-align: left;">Define a value</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>42 :: Int</code></td>
<td style="text-align: left;">Type annotation</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>a -&gt; b</code></td>
<td style="text-align: left;">Function from <code>a</code> to <code>b</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[1, 2, 3]</code></td>
<td style="text-align: left;">List</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>1 : [2, 3]</code></td>
<td style="text-align: left;">Prepend to a list</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&quot;He&quot; ++ &quot;llo&quot;</code></td>
<td style="text-align: left;">Concatenate two lists</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>where</code></td>
<td style="text-align: left;">scoped definition</td>
</tr>
</tbody>
</table>
</section></section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					// { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					// { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
